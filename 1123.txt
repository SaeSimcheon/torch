
mapping에 sub의 문자를 대체할 수 있는 문자를 길이 2짜리 리스트 보관

이때 mapping의 원소는 sub에 적용될 수도 있고 그렇지 않을 수도 있다

한 문자에 대해 다수의 문자가 대응될 수 있다 (ex t -> 7 or 8)

mapping의 원소를 이용해 적절히 sub의 문자를 대체하여 s에 substring으로 만들 수 있는지 확인하는 문제

- 반대로 s를 구성하는 문자들을 mapping의 원소를 반대로 적용하여 풀 수 있지 않을까 생각했었음
- 일대다 대응, 적용하지 않음 등이 문제를 복잡하게 만들었음
- mapping에 관계가 나타나 있지 않은 sub의 문자가 있을 수 있음
- brute force하게 모든 경우의 수를 구해서 s의 부분 문자열이 되는지 확인하려 했었으나
경우의 수가 무수히 많아 탐색하기 어렵다고 판단 했음
예를들어 예제 1에서 sub에 e가 2개 밖에 없지만 몇 백개로 늘리고 그에 맞춰
s에서도 대응 되도록 늘리면 그 경우의 수 따지는 것만으로도 많은 시간이 소모될 것으로 예상
sub와 s의 길이가 최대 5천까지인 것을 감안하면 시간 초과가 나올 가능성이 매우 높아
부적절한 풀이로 생각했다
- sub내에서 서로 다른 문자이더라도 mapping에서 같은 문자로 대응될 수 있음
-> 편의에 따라 다르게 만들 수 있다?


- sub를 s에 대응시키며 mapping을 고려했을때 일치시킬 수 있는지 확인하면 해결할 
수 있을 것 같음
-> 이를 위해서 s용 dictionary와 sub용 dictionary를 각각 만들기로 함
-> 그냥 sub을 이동시켜 s를 순회하며 각 index에 대응되는 원소를 sub으로부터 만들 수 있는지만
확인하면 됨

# kmp에 dictionary를 적용해서 != 조건을 in not in으로 대체하여 적용하였음
# 만약 n이 sub의 길이와 같아지면 그때 True를 리턴 그렇지 않으면 False


# kmp -> 반례 존재
-> lps 를 이용하는 과정 생략하고 index를 하나씩 옮겨 가며 substring인지
판별하는 작접을 진행


# sub의 길이만큼 s에 대응하여 부분문자열인지 판별할때 도중에 부분문자열이 될 수 없는
경우를 판별하여 False를 리턴하는 것이 되는 경우마다 n+=1을 하는 것보다 빠름
즉, 아닌 경우에 바로 중도 이탈이 가능하다는 점을 이용해 시간을 줄일 수 있음
-> 이거 하나로 2배 정도 속도의 차이가 남.



a                              z 같지 않음 
a                             az 같음
az




- 포기했고 dp 풀이 z 알고리즘 hash 맵 풀이 3개 공부하고 넘어가려고 함

